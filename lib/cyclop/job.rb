module Cyclop
  class Job
    # Unique identifier
    attr_accessor :_id
    # Queue name
    attr_accessor :queue
    # Parameters sent to `#perform`
    attr_accessor :job_params
    # Delay in seconds
    attr_accessor :delay
    # Time until we do start the job
    attr_accessor :delayed_until
    # Number of retries before being marked as failed
    attr_accessor :retries
    # Time in seconds between retry
    attr_accessor :splay
    # Host it's added under
    attr_accessor :created_by
    # Time it was created
    attr_accessor :created_at
    # Time it was last updated
    attr_accessor :updated_at
    # Worker unique identifier
    attr_accessor :locked_by
    # Time when worker started
    attr_accessor :locked_at
    # Mark as failed
    attr_accessor :failed
    # Number of attempts
    attr_accessor :attempts
    # Backtraces of unsuccessful attempts
    attr_accessor :errors

    def initialize(attrs={})
      raise ArgumentError, ":queue is required" unless attrs["queue"] || attrs[:queue]
      self.attributes = attrs
    end

    # Create a new job and save it to the queue specified in `opts[:queue]`
    def self.create(opts={})
      job = new opts
      job.save
      job
    end

    # Get the next job from any `opts[:queues]` and mark it as locked
    def self.next(opts={})
      raise ArgumentError, "locked_by is required" unless opts[:locked_by]

      time_now = Time.now.utc

      conditions = {query: {}}
      # Not failed jobs only
      conditions[:query][:failed] = false
      # Only jobs generated by the specified host if present
      conditions[:query][:created_by] = opts[:host] if opts[:host]
      # Skip delayed jobs
      conditions[:query][:delayed_until] = {"$lte" => time_now}
      # Filter by queue if present
      conditions[:query][:queue] = {"$in" => opts[:queues]} if opts[:queues] && !opts[:queues].empty?
      # Skip locked jobs
      conditions[:query]["$or"] = [{locked_at: {"$lte" => time_now - 1800}}, {locked_at: nil}]
      # Last chance to skip dead jobs
      conditions[:query]["$where"] = "this.attempts <= this.retries"

      # Set `locked_by` with worker id and increment the number of attempts
      conditions[:update] = {
        "$set" => {
          locked_by: opts[:locked_by],
          locked_at: time_now,
        },
        "$inc" => {
          attempts: 1
        }
      }
      
      # Sort by `created_at`
      conditions[:sort] = [:created_at, :asc]

      # Returns the modified job
      conditions[:new] = true

      job = collection.find_and_modify conditions
      new job if job
    rescue Mongo::OperationFailure
      nil
    end
    
    # Get failed jobs from any `opts[:queues]`
    def self.failed(opts={})
      selector = {}
      # Failed or dead jobs only
      selector["$or"] = [
        {failed: true}, 
        {"$where" => "this.attempts > this.retries"},
      ]
      # Filter by queue if present
      selector[:queue] = {"$in" => opts[:queues]} if opts[:queues] && !opts[:queues].empty?

      options = {}
      options[:skip] = opts[:skip] if opts[:skip]
      options[:limit] = opts[:limit] if opts[:limit]

      collection.find(selector, options).collect{|attrs| new attrs}
    end
    
    def self.find(id)
      if doc = collection.find_one(id)
        new doc
      end
    end

    # Save to queue
    def save
      self.updated_at = Time.now.utc
      if persisted?
        raise NotImplementedError
      else
        self.created_at = updated_at
        self.delayed_until = ::Time.at(created_at.to_i + delay).utc
        self._id = collection.insert attributes, safe: true
      end
      true
    rescue Mongo::OperationFailure
      false
    end

    def reload
      self.attributes = collection.find_one _id
      self
    end

    # If we have an id the object is persisted
    def persisted?
      !!_id
    end
    
    def ==(other)
      other._id == _id
    end
    
    # Remove successfully processed job from the queue
    def complete!
      collection.remove _id: _id, locked_by: Cyclop.master_id
    end

    # Release job for further processing
    def release!(exception = nil)
      now = ::Time.at(Time.now.to_i).utc
      selector = {_id: _id, locked_by: Cyclop.master_id}
      set = if attempts<=retries
        {locked_by: nil, locked_at: nil, delayed_until: now+splay}
      else
        {failed: true}
      end
      update = {"$set" => set}
      update["$push"] = {
        :errors => {
          :locked_by => locked_by,
          :locked_at => locked_at,
          :class => exception.class.name,
          :message => exception.message,
          :backtrace => exception.backtrace,
          :created_at => now,
        },
      } if exception
      collection.update selector, update, :safe => true
    end
    
    def requeue
      self.attempts, self.failed, self.locked_at = 0, false, nil
      update = {attempts: attempts, failed: failed, locked_at: locked_at}
      collection.update({_id: _id}, {"$set" => update}, :safe => true)
    end

  private
    def self.collection
      @@collection ||= Cyclop.db ?
        Cyclop.db["cyclop_jobs"] : raise(Cyclop::DatabaseNotAvailable)
    end
    
    def collection
      self.class.collection
    end

    def attributes
      {
        queue: queue,
        job_params: job_params,
        delay: delay,
        delayed_until: delayed_until,
        retries: retries,
        splay: splay,
        created_by: created_by,
        created_at: created_at,
        updated_at: updated_at,
        locked_by: locked_by,
        locked_at: locked_at,
        failed: failed,
        attempts: attempts,
        errors: errors,
      }
    end

    def attributes=(attrs)
      attrs.each do |key, value|
        send "#{key}=", value
      end
      self.delay ||= 0
      self.retries ||= 0
      self.splay ||= 60
      self.created_by ||= Cyclop.host
      self.failed ||= false
      self.attempts ||= 0
      self.errors ||= []
    end
  end
end